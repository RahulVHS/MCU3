/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include "reg_util.h"
#include "stm32f429xx.h"
#include "bsp_lcd.h"
void LTDC_Pin_Init(void);
void LTDC_Init(void);
void SystemClockSetup(void);
int main(void)
{
	SystemClockSetup();
	BSP_LCD_Init();
	LTDC_Pin_Init();
	LTDC_Init();

    /* Loop forever */
	for(;;);

}


void LTDC_Init(void)
{
	LTDC_TypeDef *pLTDC=LTDC;
	REG_SET_BIT(RCC->APB2ENR,RCC_APB2ENR_LTDCEN_Pos);

	//horizontal synchronization timings
	REG_SET_VAL(pLTDC->SSCR,(BSP_LCD_HSW-1),0xFFFU,LTDC_SSCR_HSW_Pos);
	REG_SET_VAL(pLTDC->BPCR,(BSP_LCD_HSW+BSP_LCD_HBP-1),0xFFFU,LTDC_BPCR_AHBP_Pos);
	REG_SET_VAL(pLTDC->AWCR,(BSP_LCD_HSW+BSP_LCD_HBP+BSP_LCD_ACTIVE_WIDTH_LANDSCAPE-1),0xFFFU,LTDC_AWCR_AAW_Pos);
	uint32_t total_width = BSP_LCD_HSW+BSP_LCD_HBP+BSP_LCD_ACTIVE_WIDTH_LANDSCAPE+BSP_LCD_HFP-1;
	REG_SET_VAL(pLTDC->TWCR,total_width,0xFFFU,LTDC_TWCR_TOTALW_Pos);

	// Vertical synchronization timings 
	REG_SET_VAL(pLTDC->SSCR,(BSP_LCD_VSW-1),0x7FFU,LTDC_SSCR_VSH_Pos);
	REG_SET_VAL(pLTDC->BPCR,(BSP_LCD_VSW+BSP_LCD_VBP-1),0x7FFU,LTDC_BPCR_AVBP_Pos);
	REG_SET_VAL(pLTDC->AWCR,(BSP_LCD_VSW+BSP_LCD_VBP+BSP_LCD_ACTIVE_HEIGHT_LANDSCAPE-1),0x7FFU,LTDC_AWCR_AAH_Pos);
	uint32_t total_height = BSP_LCD_VSW+BSP_LCD_VBP+BSP_LCD_ACTIVE_HEIGHT_LANDSCAPE+BSP_LCD_VFP-1;
	REG_SET_VAL(pLTDC->TWCR,total_height,0x7FFU,LTDC_TWCR_TOTALH_Pos);

		//Configure the background color(RED)
		REG_SET_VAL(LTDC->BCCR, 0xFF0000U, 0xFFFFFFU, LTDC_BCCR_BCBLUE_Pos);

		//default polarity for hsync, vsync, ltdc_clk, DE
		//TODO

		//enable the LTDC peripheral
		REG_SET_BIT(pLTDC->GCR,LTDC_GCR_LTDCEN_Pos);


}

void LTDC_Pin_Init(void)
{
	//enable the peripheral clock for GPIO ports involved in LTDC interface
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOAEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOBEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOCEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIODEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOGEN_Pos);
	REG_SET_BIT(RCC->AHB1ENR,RCC_AHB1ENR_GPIOFEN_Pos);

	for(int i = 0 ; i < total_ltdc_pins ;i++){
		REG_SET_VAL(ltdc_io_ports[i]->MODER,2U,0x3U,(ltdc_pins[i] * 2U));
		REG_CLR_BIT(ltdc_io_ports[i]->OTYPER,ltdc_pins[i]);
		REG_SET_VAL(ltdc_io_ports[i]->OSPEEDR,2U,0x3U,(ltdc_pins[i] * 2U));

		if(ltdc_pins[i] < 8)
			REG_SET_VAL(ltdc_io_ports[i]->AFR[0],ltdc_af_values[i],0xFU,(ltdc_pins[i] * 4U));
		else
			REG_SET_VAL(ltdc_io_ports[i]->AFR[1],ltdc_af_values[i],0xFU,((ltdc_pins[i] % 8) * 4U));
	}
}

void SystemClockSetup(void)
{
	RCC_TypeDef *pRCC=RCC;
	FLASH_TypeDef *pFlash=FLASH;
	PWR_TypeDef *pPWR=PWR;

	//1.prohram flash wait states
	REG_SET_VAL(pFlash->ACR,0x5U,0xFU,FLASH_ACR_LATENCY_Pos);

	//2. overdrive modes
	REG_SET_BIT(pRCC->APB1ENR,RCC_APB1ENR_PWREN_Pos);
	REG_SET_VAL(pPWR->CR,0x3,0x3,PWR_CR_VOS_Pos);
	REG_SET_BIT(pPWR->CR,PWR_CR_ODEN_Pos);
	while(!REG_READ_BIT(pPWR->CSR,PWR_CSR_ODRDY_Pos));
	REG_SET_BIT(pPWR->CR,PWR_CR_ODSWEN_Pos);

	//REG_SET_BIT(pRCC->CR, RCC_CR_HSEON_Pos);           /* Turn on HSE (8MHz crystal) */
	 //   while (!REG_READ_BIT(pRCC->CR, RCC_CR_HSERDY_Pos));

	//1. set the mainPLL
	//3. setting up the main PLL
	REG_SET_VAL(pRCC->PLLCFGR,0x8U,0x3FU,RCC_PLLCFGR_PLLM_Pos);//PLL_M
	REG_SET_VAL(pRCC->PLLCFGR,180U,0x1FFU,RCC_PLLCFGR_PLLN_Pos);//PLL_N
	REG_SET_VAL(pRCC->PLLCFGR,0x00U,0x3U,RCC_PLLCFGR_PLLP_Pos);//PLL_P

	//4. setting up the LC_CLK using PLLSAI block
	REG_SET_VAL(pRCC->PLLSAICFGR,50U,0x1FFU,RCC_PLLSAICFGR_PLLSAIN_Pos);
	REG_SET_VAL(pRCC->PLLSAICFGR,0x02U,0x7U,RCC_PLLSAICFGR_PLLSAIR_Pos);

//LCD_CLK= 6.25MHZ
	REG_SET_VAL(pRCC->DCKCFGR,0x02U,0x3U,RCC_DCKCFGR_PLLSAIDIVR_Pos);
	REG_SET_BIT(pRCC->CR,RCC_CR_PLLSAION_Pos);
		while(!REG_READ_BIT(pRCC->CR,RCC_CR_PLLSAIRDY_Pos));

	//5. setting up the AHB and APBX clocks
	REG_SET_VAL(pRCC->CFGR,0U,0xFU,RCC_CFGR_HPRE_Pos);//AHB prescalar
	REG_SET_VAL(pRCC->CFGR,0x5U,0x7U,RCC_CFGR_PPRE1_Pos);//APB1 prescalar
	REG_SET_VAL(pRCC->CFGR,0x4U,0x7U,RCC_CFGR_PPRE2_Pos);//APB2 prescalar

	//6. TURN on PLL and wait for PLLClk ready
	REG_SET_BIT(pRCC->CR,RCC_CR_PLLON_Pos);
	while(!REG_READ_BIT(pRCC->CR,RCC_CR_PLLRDY_Pos));
	//7. Switch PLLCLK as SYSCLK
	REG_SET_VAL(pRCC->CFGR,0x2U,0x3U,RCC_CFGR_SW_Pos);
		while(!(REG_READ_VAL(pRCC->CFGR,0x3u,RCC_CFGR_SWS_Pos)== 0x2U));
}














